package com.example.k5_iot_springboot.이론;

/*
    === 스프링부트 구조 ===
    1. 스프링 (Spring Framework) 이란?
    : 엔터프라이즈 애플리케이션 개발을 위한 자바 기반의 강력한 프레임워크
    - 대규모, 복잡한 데이터 관리를 위한 서버 성능, 안정성, 보안 기능 제공
    - 초기 설정 시 XML 설정, 환경 구성 필요 (학습 곡선 높음)

    2. 스프링 부트 (Spring Boot)란?
    : 스프링을 쉽고 빠르게 사용할 수 있도록 지원하는 프레임 워크 확장판
    - 스프링 부트 스타터 제공 (빌드 & 의존성 관리 최소화)
    - XML 설정 없이 JAVA 코드 기반 설정 가능 (Annotation 기반)
    - 내장 WAS(Tomcat 등)를 포함: 별도 설치 없이 실행 가능
    - JAR 파일만으로 서브 실행 및 배포 가능 (외부 서버 설치 불필요)

    3. 스프링 부트의 동작 구조

    [클라이언트] - [서블릿 컨테이너] - [Dispatcher Servlet]
                                            |
                             뷰 / 핸들러 매핑 / 핸들러 어댑터 / 뷰 리졸버
                                                   |
                                                컨트롤러

    1) 클라이언트 >> 서블릿 컨테이너 >> Dispatcher Servlet(DS)
        : 클라이언트에서 "요청"이 들어오면
            , 서블릿 컨테이너(Tomcat)가 URL 매핑에 따라 해당 요청을 DS로 전달

    2) DS >> 핸들러 매핑
        : 해당 요청(URL, HTTP 메서드 등)에 대응하는 핸들러(= 컨트롤러 메서드)를 찾음
        - 핸들러 매핑은 적합한 컨트롤러/핸들러 정보를 찾아서 반환

    3) DS >> 핸들러 어댑터
        : DS가 선택된 핸들러를 실행할 수 있는 어댑터를 찾아 핸들러 어댑터를 호출
        - 해당 어댑터는 실제 컨트롤러와 연결되어 컨트롤러의 메서드를 실행하고
            , 실행 결과(모델 & 뷰)를 DS에 반환
        >> 어댑터
            : 스프링은 컨트롤러 스타일이 달라도 공통 방식으로 호출 할 수 있도록 어댑터가 중간에서 표준화
            (@Controller, @RestController 등)
    4) 핸들러 어댑터 >> 컨트롤러
        : 컨트롤러가 요청 파라미터를 받아 비즈니스 로직 호출, 모델 데이터 생성, 뷰 이름(String) 등을 반환
        - @ResponseBody & @RestController 인 경우 뷰를 반환하지 않고 바디(JSON 등)로 바로 전달
            >> 뷰/ 뷰 리졸버 단계 생략 가능

    === 5 ~ 6번 무시 하셔도 되요~ ===
    5) DS >> 뷰 리졸버
        : 컨트롤러 결과가 뷰 이름이면, DS는 뷰 리졸버에게 실제 뷰 객체로 바꿀 것을 요청 (JSP/Thymeleaf 등)

    6) DS >> 뷰
        : DS가 뷰 객체에 모델 데이터를 넘겨 렌더링을 수행
          (HTML 등이 서블릿 컨테이너를 통해 클라이언트에 응답으로 전송)


    4. DispatcherServlet(디스패처 서블릿, dispatch 보내다)
    : 스프링부트의 핵심 서블릿
    - 클라이언트의 요청을 받아 "알맞은 핸들러(controller)"를 찾고 실행하며
        , 처리된 결과를 다시 클라이언트에게 반환

    1) 클라이언트 요청 처리
        : 사용자가 웹에서 요청(GET, POST, PUT, DELETE)을 보냄
            - 서블릿 컨테이너(톰캣)가 DS로 요청 전달

    2) Handler(Controller) 조회
        : Handler Mapping을 통해 요청 URI에 맞는 "핸들러" 검색
        ex) /students >> StudentController 가 매핑

    3) Handler Adapter 조회
        : 매핑한 핸들러 실행을 위한 어댑터를 찾고 Controller가 실행될 수 있는 형태로 어댑터가 변환

    4) Handler(Controller) 실행
        : 어댑터가 찾은 핸들러 실행
        - 요청 처리와 결과를 어댑터로 반환


//  ---------------------------------------------------------------  //
# SpringBoot는
    client -> 백엔드 (Tomcat-> DS로 요청 다받음)
            Dispatcher Servlet 이 편하게 다 해준다.


    === 서블릿(Servlet) VS 스프링부트(SpringBoot) ===
   1. 서블릿
        1) 각 서블릿이 컨트롤러 역할까지 직접 함 - 구조를 스스로 만들고, 규칙도 스스로 정해야 함
        2) 기능/URI 마다 여러 서블릿을 만들거나, 직접 프론트 컨트롤러 패턴(서블릿 1개 + 내부 분기)을 구현해야 함

   2. 스프링부트(MVC)
        1) DispatcherServlet 하나가 관문
            - 그 아래는 컨트롤러 메서드 단위로 라우팅
            - 공통 보일러 플레이트(바인딩, 검증, 예외, 직렬화)를 프레임워크가 제공
        2) 서블릿 레벨이 DispatcherServlet 1개면 충분 (스프링이 자동 등록)
            - 컨트롤러 클래스/메서드는 여러 개
                >> 애플리케이션 코드 레벨
                    "서블릿 여러 개"가 아니라 POJO(Plain Old Java Object) 단위라 가볍고 일관적

            cf) POJO 메서드
                : 클래스 내부에 정의된 메서드를 의미
                - 특정 프레임워크나 기술에 종속되지 않고 순수하게 데이터와 로직을 캡슐화하는 객체를 의미
 */



public class D_SpringBoot {
}
